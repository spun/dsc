{"version":3,"file":"twitch-BFTsuihE.js","sources":["../../src-bookmarklet/twitch/utils/accessUtils.ts","../../src-bookmarklet/twitch/twitch.ts"],"sourcesContent":["interface ApiResponse {\n  data: ApiResponseData\n}\n\ninterface ApiResponseData {\n  streamPlaybackAccessToken: ApiAccessToken,\n  videoPlaybackAccessToken: ApiAccessToken\n}\ninterface ApiAccessToken {\n  readonly signature: string;\n  readonly value: string;\n}\n\ninterface AccessToken {\n  readonly signature: string;\n  readonly token: string;\n}\n\n/**\n * Creates a request to get the access token using gql.\n * @param clientId The client id to use in the request.\n * @param isLive Defines if the petition is for a live channel (true) or for a VOD (false).\n * @param channelName If the petition is for a live channel, this has to be the channel name.\n * @param videoId If the petition is for a VOD, this has to be the id of the video.\n */\nasync function getAccessTokenResponse(clientId: string, isLive: boolean, channelName = '', videoId = '') : Promise<ApiResponse> {\n  const gqlTemplate = `\n    query PlaybackAccessToken_Template($login: String!, $isLive: Boolean!, $vodID: ID!, $isVod: Boolean!, $playerType: String!) {\n      streamPlaybackAccessToken(channelName: $login, params: {platform: \"web\", playerBackend: \"mediaplayer\", playerType: $playerType}) @include(if: $isLive) {\n        value\n        signature\n      }\n      videoPlaybackAccessToken(id: $vodID, params: {platform: \"web\", playerBackend: \"mediaplayer\", playerType: $playerType}) @include(if: $isVod) {\n        value\n        signature\n      }\n    }`;\n\n  // Form a gql petition\n  const gqlUrl = 'https://gql.twitch.tv/gql';\n  const requestQuery = {\n    operationName: 'PlaybackAccessToken_Template',\n    query: gqlTemplate,\n    variables: {\n      isLive,\n      login: channelName,\n      isVod: !isLive,\n      vodID: videoId,\n      playerType: 'site',\n    },\n  };\n\n  // Send request\n  const response = await fetch(gqlUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'text/plain; charset=UTF-8',\n      'Client-ID': clientId,\n    },\n    body: JSON.stringify(requestQuery),\n  });\n\n  // Return data in JSON format\n  const dataJson = await response.json();\n  return dataJson;\n}\n\nexport async function getLiveAccessToken(\n  clientId: string,\n  channelName: string,\n) : Promise<AccessToken> {\n  const dataJson = await getAccessTokenResponse(clientId, true, channelName, undefined);\n  const { value: token, signature } = dataJson.data.streamPlaybackAccessToken;\n  return { token, signature };\n}\n\nexport async function getVideoAccessToken(\n  clientId: string,\n  videoId: string,\n) : Promise<AccessToken> {\n  const dataJson = await getAccessTokenResponse(clientId, false, undefined, videoId);\n  const { value: token, signature } = dataJson.data.videoPlaybackAccessToken;\n  return { token, signature };\n}\n","import { getLiveAccessToken, getVideoAccessToken } from './utils/accessUtils';\n\ninterface CommonOptions {\n  headers: Record<string, string>;\n}\ndeclare const commonOptions: CommonOptions;\n\n/**\n * Get assigned client id\n */\nfunction getClientId() {\n  return commonOptions.headers['Client-ID'];\n}\n\n/**\n * Check it the current url is from a main/live channel page and extracts the channel name\n */\nfunction isLiveChannelUrl() {\n  // A live channel only has the name of the channel in its pathname\n  const { pathname } = window.location;\n  const regExp = /^\\/(\\w+)\\/?$/;\n  const match = pathname.match(regExp);\n  if (match) {\n    return match[1];\n  }\n  return false;\n}\n\n/**\n * Get the manifest (m3u8 file) of a live channel\n */\nasync function getManifestLiveUrl(channelName: string, clientId: string) {\n  const accessToken = await getLiveAccessToken(clientId, channelName);\n  // Form url\n  const { signature } = accessToken;\n  const encodedToken = encodeURIComponent(accessToken.token);\n  return `https://usher.ttvnw.net/api/channel/hls/${channelName}.m3u8?sig=${signature}&token=${encodedToken}`;\n}\n\n/**\n * Check it the url is from a vod page with the type 1 format and extract the video id\n * Format: twitch.tv/videos/<videoId>\n */\nfunction getVodIdType1(url: string) {\n  const regExp = /^.*twitch\\.tv\\/videos\\/([0-9]+)*/;\n  const match = url.match(regExp);\n  if (match) {\n    return match[1];\n  }\n  return undefined;\n}\n\n/**\n * Check it the url is from a vod page with the type 2 format and extract the video id\n * Format: twitch.tv/<channelName>/video/<videoId>\n */\nfunction getVodIdType2(url: string) {\n  const regExp = /^.*twitch\\.tv\\/.*\\/video\\/([0-9]+)*/;\n  const match = url.match(regExp);\n  if (match) {\n    return match[1];\n  }\n  return undefined;\n}\n\n/**\n * Check it the current url is from a vod page and extracts the video id\n */\nfunction getVodId() {\n  const locationUrl = window.location.href;\n  return getVodIdType1(locationUrl) || getVodIdType2(locationUrl);\n}\n\n/**\n * Get the manifest (m3u8 file) of a live channel\n */\nasync function getManigestVideoUrl(videoId: string, clientId: string) {\n  const accessToken = await getVideoAccessToken(clientId, videoId);\n  // Form url\n  const { signature } = accessToken;\n  const encodedToken = encodeURIComponent(accessToken.token);\n  return `https://usher.ttvnw.net/vod/${videoId}.m3u8?sig=${signature}&token=${encodedToken}`;\n}\n\nasync function main(): Promise<void> {\n  // Check if the request is for a live channel\n  const channelName = isLiveChannelUrl();\n  if (channelName) {\n    const clientId = getClientId();\n    const liveManifestUrl = await getManifestLiveUrl(channelName, clientId);\n    window.location.href = liveManifestUrl;\n  } else {\n    // Check if the request was for a vod\n    const vodId = getVodId();\n    if (vodId) {\n      const clientId = getClientId();\n      const videoManifestUrl = await getManigestVideoUrl(vodId, clientId);\n      window.location.href = videoManifestUrl;\n    }\n  }\n}\n\nexport default main;\n"],"names":["getAccessTokenResponse","clientId","isLive","channelName","videoId","requestQuery","operationName","query","variables","login","isVod","vodID","playerType","response","fetch","method","headers","body","JSON","stringify","json","getClientId","commonOptions","getManifestLiveUrl","accessToken","dataJson","undefined","value","token","signature","data","streamPlaybackAccessToken","getLiveAccessToken","encodedToken","encodeURIComponent","getManigestVideoUrl","videoPlaybackAccessToken","getVideoAccessToken","main","pathname","window","location","match","isLiveChannelUrl","liveManifestUrl","href","vodId","locationUrl","url","getVodIdType1","getVodIdType2","getVodId","videoManifestUrl"],"mappings":"4CAyBA,SAAeA,EAAuBC,EAAkBC,EAAiBC,EAAc,GAAIC,EAAU,6CACnG,MAcMC,EAAe,CACnBC,cAAe,+BACfC,MAhBkB,whBAiBlBC,UAAW,CACTN,SACAO,MAAON,EACPO,OAAQR,EACRS,MAAOP,EACPQ,WAAY,SAKVC,QAAiBC,MAdR,4BAcsB,CACnCC,OAAQ,OACRC,QAAS,CACP,eAAgB,4BAChB,YAAaf,GAEfgB,KAAMC,KAAKC,UAAUd,KAKvB,aADuBQ,EAASO,SAEjC,CCvDD,SAASC,IACP,OAAOC,cAAcN,QAAQ,YAC/B,CAmBA,SAAeO,EAAmBpB,EAAqBF,4CACrD,MAAMuB,QDmCc,SACpBvB,EACAE,4CAEA,MAAMsB,QAAiBzB,EAAuBC,GAAU,EAAME,OAAauB,IACnEC,MAAOC,EAAKC,UAAEA,GAAcJ,EAASK,KAAKC,0BAClD,MAAO,CAAEH,QAAOC,eACjB,CC1C2BG,CAAmB/B,EAAUE,IAEjD0B,UAAEA,GAAcL,EAChBS,EAAeC,mBAAmBV,EAAYI,OACpD,MAAO,2CAA2CzB,cAAwB0B,WAAmBI,MAC9F,CAuCD,SAAeE,EAAoB/B,EAAiBH,4CAClD,MAAMuB,QDDc,SACpBvB,EACAG,4CAEA,MAAMqB,QAAiBzB,EAAuBC,GAAU,OAAOyB,EAAWtB,IAClEuB,MAAOC,EAAKC,UAAEA,GAAcJ,EAASK,KAAKM,yBAClD,MAAO,CAAER,QAAOC,eACjB,CCN2BQ,CAAoBpC,EAAUG,IAElDyB,UAAEA,GAAcL,EAChBS,EAAeC,mBAAmBV,EAAYI,OACpD,MAAO,+BAA+BxB,cAAoByB,WAAmBI,MAC9E,CAED,SAAeK,6CAEb,MAAMnC,EArER,WAEE,MAAMoC,SAAEA,GAAaC,OAAOC,SAEtBC,EAAQH,EAASG,MADR,gBAEf,QAAIA,GACKA,EAAM,EAGjB,CA4DsBC,GACpB,GAAIxC,EAAa,CACf,MAAMF,EAAWoB,IACXuB,QAAwBrB,EAAmBpB,EAAaF,GAC9DuC,OAAOC,SAASI,KAAOD,CACxB,KAAM,CAEL,MAAME,EAzBV,WACE,MAAMC,EAAcP,OAAOC,SAASI,KACpC,OA3BF,SAAuBG,GACrB,MACMN,EAAQM,EAAIN,MADH,oCAEf,GAAIA,EACF,OAAOA,EAAM,EAGjB,CAoBSO,CAAcF,IAdvB,SAAuBC,GACrB,MACMN,EAAQM,EAAIN,MADH,uCAEf,GAAIA,EACF,OAAOA,EAAM,EAGjB,CAOuCQ,CAAcH,EACrD,CAsBkBI,GACd,GAAIL,EAAO,CACT,MAAM7C,EAAWoB,IACX+B,QAAyBjB,EAAoBW,EAAO7C,GAC1DuC,OAAOC,SAASI,KAAOO,CACxB,CACF,IACF"}